[AST] /mnt/c/Users/afariasa/Software/cpp-bonsai/tests/input/cross_file_ref.cpp
[7:11] NAMESPACE: aNamespace 'aNamespace' [USR:c:@N@aNamespace] [32 tokens]
| [9:7] CLASS_DECL: C 'C' (TypeKind.RECORD: aNamespace::C) [USR:c:@N@aNamespace@S@C] [20 tokens]
| | [10:1] CXX_ACCESS_SPEC_DECL: [no spelling] [USR:c:] [AccessSpecifier.PUBLIC] [2 tokens] [('public', 'KEYWORD'), (':', 'PUNCTUATION')]
| | [11:10] CXX_METHOD: aMethod 'aMethod(int)' (TypeKind.FUNCTIONPROTO: void (int)) (-> TypeKind.VOID: void) [USR:c:@N@aNamespace@S@C@F@aMethod#I#] [AccessSpecifier.PUBLIC] [6 tokens]
| | | [11:22] PARM_DECL: a 'a' (TypeKind.INT: int) [USR:c:cross_file_def.hpp@200@N@aNamespace@S@C@F@aMethod#I#@a] [2 tokens] [('int', 'KEYWORD'), ('a', 'IDENTIFIER')]
| | [12:1] CXX_ACCESS_SPEC_DECL: [no spelling] [USR:c:] [AccessSpecifier.PRIVATE] [2 tokens] [('private', 'KEYWORD'), (':', 'PUNCTUATION')]
| | [13:9] FIELD_DECL: x_ 'x_' (TypeKind.INT: int) [USR:c:@N@aNamespace@S@C@FI@x_] [AccessSpecifier.PRIVATE] [4 tokens] [('int', 'KEYWORD'), ('x_', 'IDENTIFIER'), ('=', 'PUNCTUATION'), ('0', 'LITERAL')]
| | | [13:14] INTEGER_LITERAL: [no spelling] (TypeKind.INT: int) [1 tokens] [('0', 'LITERAL')]
| [16:5] FUNCTION_DECL: aFunction 'aFunction(int)' (TypeKind.FUNCTIONPROTO: int (int)) (-> TypeKind.INT: int) [USR:c:@N@aNamespace@F@aFunction#I#] [6 tokens]
| | [16:19] PARM_DECL: a 'a' (TypeKind.INT: int) [USR:c:cross_file_def.hpp@256@N@aNamespace@F@aFunction#I#@a] [2 tokens] [('int', 'KEYWORD'), ('a', 'IDENTIFIER')]
[6:5] FUNCTION_DECL: main 'main(int, char **)' (TypeKind.FUNCTIONPROTO: int (int, char **)) (-> TypeKind.INT: int) [USR:c:@F@main#I#**C#] [38 tokens]
| [6:14] PARM_DECL: argc 'argc' (TypeKind.INT: int) [USR:c:cross_file_ref.cpp@113@F@main#I#**C#@argc] [2 tokens] [('int', 'KEYWORD'), ('argc', 'IDENTIFIER')]
| [6:27] PARM_DECL: argv 'argv' (TypeKind.POINTER: char **) [USR:c:cross_file_ref.cpp@123@F@main#I#**C#@argv] [4 tokens] [('char', 'KEYWORD'), ('*', 'PUNCTUATION'), ('*', 'PUNCTUATION'), ('argv', 'IDENTIFIER')]
| [6:33] COMPOUND_STMT: [no spelling] [27 tokens]
| | [7:5] DECL_STMT: [no spelling] [5 tokens]
| | | [7:19] VAR_DECL: c 'c' (TypeKind.RECORD: aNamespace::C) [USR:c:cross_file_ref.cpp@143@F@main#I#**C#@c] [4 tokens] [('aNamespace', 'IDENTIFIER'), ('::', 'PUNCTUATION'), ('C', 'IDENTIFIER'), ('c', 'IDENTIFIER')]
| | | | [7:5] NAMESPACE_REF: aNamespace 'aNamespace' [1 tokens] [('aNamespace', 'IDENTIFIER')]
| | | | [7:17] TYPE_REF: class aNamespace::C 'class aNamespace::C' (TypeKind.RECORD: aNamespace::C) [1 tokens] [('C', 'IDENTIFIER')]
| | | | [7:19] CALL_EXPR: C 'C' (TypeKind.RECORD: aNamespace::C) [1 tokens] [('c', 'IDENTIFIER')]
| | [8:5] DECL_STMT: [no spelling] [10 tokens]
| | | [8:9] VAR_DECL: a 'a' (TypeKind.INT: int) [USR:c:cross_file_ref.cpp@165@F@main#I#**C#@a] [9 tokens]
| | | | [8:13] CALL_EXPR: aFunction 'aFunction' (TypeKind.INT: int) [6 tokens]
| | | | | [8:25] UNEXPOSED_EXPR: aFunction 'aFunction' (TypeKind.POINTER: int (*)(int)) [3 tokens] [('aNamespace', 'IDENTIFIER'), ('::', 'PUNCTUATION'), ('aFunction', 'IDENTIFIER')]
| | | | | | [8:25] DECL_REF_EXPR: aFunction 'aFunction' (TypeKind.FUNCTIONPROTO: int (int)) [3 tokens] [('aNamespace', 'IDENTIFIER'), ('::', 'PUNCTUATION'), ('aFunction', 'IDENTIFIER')]
| | | | | | | [8:13] NAMESPACE_REF: aNamespace 'aNamespace' [1 tokens] [('aNamespace', 'IDENTIFIER')]
| | | | | [8:35] INTEGER_LITERAL: [no spelling] (TypeKind.INT: int) [1 tokens] [('2', 'LITERAL')]
| | [9:5] CALL_EXPR: aMethod 'aMethod' (TypeKind.VOID: void) [6 tokens]
| | | [9:7] MEMBER_REF_EXPR: aMethod 'aMethod' (TypeKind.UNEXPOSED: <bound member function type>) [3 tokens] [('c', 'IDENTIFIER'), ('.', 'PUNCTUATION'), ('aMethod', 'IDENTIFIER')]
| | | | [9:5] DECL_REF_EXPR: c 'c' (TypeKind.RECORD: aNamespace::C) [1 tokens] [('c', 'IDENTIFIER')]
| | | [9:15] UNEXPOSED_EXPR: a 'a' (TypeKind.INT: int) [1 tokens] [('a', 'IDENTIFIER')]
| | | | [9:15] DECL_REF_EXPR: a 'a' (TypeKind.INT: int) [1 tokens] [('a', 'IDENTIFIER')]
| | [10:5] RETURN_STMT: [no spelling] [2 tokens] [('return', 'KEYWORD'), ('0', 'LITERAL')]
| | | [10:12] INTEGER_LITERAL: [no spelling] (TypeKind.INT: int) [1 tokens] [('0', 'LITERAL')]